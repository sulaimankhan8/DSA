====================================================
                âœ… CORE DSA TECHNIQUES
         Complete Guide with Explanations & Algorithms
====================================================

1ï¸âƒ£ Brute Force
----------------------------------------------------
- Idea: Try every possible solution and pick the best result.
- Complexity: Often O(nÂ²), O(nÂ³), or worse.
- When to use: Small input sizes or as a starting solution.
- Example: Check every pair for a sum in an array.
- Algorithm Used: Nested loops or recursion with all choices tried.

2ï¸âƒ£ Greedy Algorithms
----------------------------------------------------
- Principle: Choose the locally optimal option at each step.
- Not all problems can be solved greedily unless proven by:
  - Greedy-choice property & Optimal substructure.
- Famous Algorithms:
  - Activity Selection Problem (Earliest finish time first)
  - Huffman Encoding Tree (Min-heap based)
  - Kruskalâ€™s MST (Union-Find for cycle detection)
  - Fractional Knapsack (Sort by value/weight ratio)

3ï¸âƒ£ Divide and Conquer
----------------------------------------------------
- Split the problem into smaller pieces, solve them recursively, then combine.
- Used for sorting, searching, and geometry problems.
- Common Algorithms:
  - Merge Sort (O(n log n))
  - Quick Sort (Expected O(n log n))
  - Binary Search (O(log n))
  - Closest Pair of Points (O(n log n))

4ï¸âƒ£ Recursion
----------------------------------------------------
- Function calls itself with smaller subproblems until reaching a base case.
- Can lead to exponential complexity if not optimized.
- Algorithms Using Recursion:
  - Tower of Hanoi (O(2^n))
  - Fibonacci Sequence (Exponential without memoization)
  - Factorial (O(n))

5ï¸âƒ£ Backtracking
----------------------------------------------------
- Recursive trial-and-error with reverting choices ("undo" step).
- Used when all solutions or one valid solution needs to be found.
- Algorithms:
  - N-Queens problem
  - Sudoku solver
  - Generating permutations & combinations (recursive calls with choice revert)

6ï¸âƒ£ Dynamic Programming (DP)
----------------------------------------------------
- Store solutions to subproblems to avoid re-computation.
- Two Approaches:
  - Top-down (Memoization)
  - Bottom-up (Tabulation)
- Algorithms:
  - Longest Common Subsequence (O(n*m))
  - Knapsack Problem (0/1 Knapsack DP)
  - Coin Change (Minimum coins or number of ways)
  - Edit Distance (Levenshtein Distance)

7ï¸âƒ£ Sliding Window
----------------------------------------------------
- Use a fixed-size or variable-size window to find optimal subarrays or substrings.
- Algorithms:
  - Kadaneâ€™s Algorithm (Max subarray sum in O(n))
  - Longest substring without repeating characters (HashSet + window expansion)
  - Sliding Window Maximum (Deque/Monotonic Queue based)

8ï¸âƒ£ Two Pointers
----------------------------------------------------
- Two pointers moving inward or outward to reduce complexity.
- Algorithms:
  - Merge Two Sorted Arrays
  - Reverse a String
  - Trap Rainwater (Two pointer method)

9ï¸âƒ£ Binary Search
----------------------------------------------------
- Works on sorted/monotonic arrays or answers.
- Algorithms:
  - Standard Binary Search
  - Lower Bound / Upper Bound search
  - Search in Rotated Sorted Array
  - Binary Search on Answer (Minimize/Maximize search ranges)

ğŸ”Ÿ Bit Manipulation
----------------------------------------------------
- Using bitwise operators for efficient operations.
- Algorithms:
  - Check if number is a power of two (n & (n-1) == 0)
  - Find single non-repeating number (XOR)
  - Count set bits (Kernighanâ€™s Algorithm)
  - Swap numbers without temp using XOR

1ï¸âƒ£1ï¸âƒ£ Graph Algorithms
----------------------------------------------------
- BFS (Queue based, level-by-level traversal)
- DFS (Recursive or iterative using stack)
- Dijkstraâ€™s Algorithm (Min-heap based for shortest paths)
- Bellman-Ford (Detect negative cycles)
- Floyd-Warshall (All pairs shortest paths)
- Kruskalâ€™s MST (Sort edges + Union-Find)
- Primâ€™s MST (Min-heap based)
- Topological Sort (Kahnâ€™s Algorithm or DFS-based)
- Union-Find (Disjoint Set Union for connectivity and cycle detection)

1ï¸âƒ£2ï¸âƒ£ Heap / Priority Queue
----------------------------------------------------
- Retrieve smallest/largest element efficiently (log n complexity).
- Algorithms:
  - Heap Sort
  - Kth Largest Element
  - Merge k Sorted Lists
  - Median of Data Stream

1ï¸âƒ£3ï¸âƒ£ Trie (Prefix Tree)
----------------------------------------------------
- Stores strings character by character in tree form.
- Used for:
  - Autocomplete
  - Spell checking
  - Longest common prefix finding
  - Search in dictionaries (O(L) complexity where L is word length)

1ï¸âƒ£4ï¸âƒ£ Segment Tree & Fenwick Tree (BIT)
----------------------------------------------------
- Data structures for dynamic range queries with updates.
- Segment Tree: O(log n) updates & queries
- Fenwick Tree: O(log n) updates & queries
- Applications:
  - Range sum, Range min/max queries
  - Frequency queries
  - Inversion count

1ï¸âƒ£5ï¸âƒ£ Prefix Sum / Difference Array
----------------------------------------------------
- Precompute prefix sums for O(1) range queries.
- Difference Array used for efficient range updates.
- Applications:
  - Range sum queries
  - Applying multiple range updates efficiently

1ï¸âƒ£6ï¸âƒ£ Stack / Monotonic Stack
----------------------------------------------------
- LIFO structure.
- Applications:
  - Parentheses matching
  - Largest rectangle in histogram (O(n))
  - Next Greater/Smaller Element (O(n) using stack)

1ï¸âƒ£7ï¸âƒ£ Queue / Deque / Monotonic Queue
----------------------------------------------------
- FIFO (Queue), Double-ended structure (Deque)
- Applications:
  - BFS traversal
  - Sliding window maximum/minimum
  - 0-1 BFS (Used for shortest path when edge weights are 0 or 1)

1ï¸âƒ£8ï¸âƒ£ Hashing
----------------------------------------------------
- Map keys to values in O(1) expected time.
- Applications:
  - Frequency count
  - Anagram detection
  - Caching results (Memoization in DP)
  - Hash-based lookup tables

1ï¸âƒ£9ï¸âƒ£ Disjoint Set (Union-Find)
----------------------------------------------------
- Data structure to manage disjoint sets.
- Algorithms:
  - Union by rank & Path compression (Optimizations)
  - Used in cycle detection, Kruskalâ€™s MST, connectivity queries

2ï¸âƒ£0ï¸âƒ£ Mathematical Techniques
----------------------------------------------------
- GCD (Euclidâ€™s Algorithm)
- LCM (lcm(a,b) = (a*b) / gcd(a,b))
- Prime Sieves (Sieve of Eratosthenes for O(n log log n))
- Modular Arithmetic:
  - Fast Exponentiation (Binary exponentiation)
  - Modular inverse (Fermatâ€™s little theorem)
  - nCr modulo (Precompute factorial & inverse)
- Combinatorics:
  - Permutations & Combinations
  - Counting paths & subsets

====================================================
ğŸš€ Save and master this â€” every major DSA concept in one place! 
====================================================

âš¡ SUMMARY TABLE âš¡

| Technique                 | Common Use                                         |
|---------------------------|----------------------------------------------------|
| Brute Force               | Small inputs, first attempt                        |
| Greedy                    | Local optimal -> global optimal problems           |
| Divide & Conquer          | Sorts, Searches, Closest point problems            |
| Recursion / Backtracking  | Generate all possibilities (Perms, Combos, Sudoku) |
| Dynamic Programming       | Overlapping subproblems (Knapsack, LCS)            |
| Sliding Window            | Subarray/substring problems                        |
| Two Pointers              | Sorted arrays, paired problems                     |
| Binary Search             | Search & optimization in monotonic conditions      |
| Bit Manipulation          | Optimization, toggle/check bits, parity checks     |
| Graph Algorithms          | Traversal, paths, connectivity                     |
| Heap / Priority Queue     | Scheduling, median, top k elements                 |
| Trie                      | Prefix-based string problems                       |
| Segment/Fenwick Tree      | Dynamic range queries                              |
| Monotonic Stack / Queue   | Next greater/smaller element, histogram problems   |
| Hashing                   | Lookup, frequency analysis                         |
| Union-Find (Disjoint Set) | Connectivity, cycle detection                      |
| Mathematical Techniques   | GCD, LCM, primes, combinatorics                    |

====================================================
ğŸ‘‰ Master these and you'll crush DSA interviews! ğŸ’ª
====================================================







====================================================
                  DATA STRUCTURES & ALGORITHMS
                      MASTER CHEAT SHEET
====================================================

ğŸ“ 1. CORE DATA STRUCTURES:
-----------------------------------------
âœ… Arrays  
âœ… Strings  
âœ… Linked Lists (Singly / Doubly)  
âœ… Stacks (LIFO)  
âœ… Queues (FIFO)  
âœ… Priority Queues & Heaps (Min-Heap, Max-Heap)  
âœ… HashMaps / HashTables / HashSets  
âœ… Trees  
   - Binary Trees  
   - Binary Search Trees  
   - AVL Trees  
   - Segment Trees  
   - Fenwick Tree (BIT)  
âœ… Tries  
âœ… Graphs (Adjacency List, Adjacency Matrix)  
âœ… Disjoint Set Union (DSU / Union-Find)  

----------------------------------------------------
ğŸ“ 2. ALGORITHM TECHNIQUES:
----------------------------------------------------
âœ… Two Pointers  
âœ… Sliding Window  
âœ… Binary Search  
âœ… Recursion  
âœ… Backtracking  
âœ… Divide & Conquer  
âœ… Dynamic Programming (DP)  
   - Memoization (Top Down)  
   - Tabulation (Bottom Up)  
âœ… Bit Manipulation  
âœ… Greedy Algorithms  
âœ… Graph Algorithms  
   - BFS (Breadth-First Search)  
   - DFS (Depth-First Search)  
   - Dijkstraâ€™s Algorithm  
   - Bellman-Ford Algorithm  
   - Floyd-Warshall Algorithm  
   - Topological Sort  
   - Union-Find / DSU  
âœ… Fast Exponentiation  
âœ… Kadaneâ€™s Algorithm  
âœ… KMP Algorithm (String Matching)  
âœ… Rabin-Karp (String Search)  
âœ… Z-Algorithm (Pattern Matching)  
âœ… Prefix Sum / Suffix Sum  

----------------------------------------------------
ğŸ“ 3. COMMON PROBLEM PATTERNS:
----------------------------------------------------
âœ… Subarray problems  
âœ… Combinational subsets  
âœ… Permutations  
âœ… Matrix traversal  
âœ… Interval problems (merge intervals, meeting rooms)  
âœ… Stock Buy-Sell problems  
âœ… Knapsack problems  
âœ… Coin change problems  

----------------------------------------------------
ğŸ“ 4. COMPLEXITY CHEAT SHEET:
----------------------------------------------------
âœ… Array search: O(n)  
âœ… Binary search: O(log n)  
âœ… Sorting: O(n log n)  
âœ… BFS/DFS: O(V + E)  
âœ… Building a heap: O(n)  
âœ… Trie Insert/Search: O(L) (L = length of word)  
âœ… DP: Often O(n^2) or O(n*m)  
âœ… Matrix Traversal: O(n*m)  

----------------------------------------------------
ğŸ“ 5. TIPS:
----------------------------------------------------
âœ… Always start with brute force.  
âœ… Look for optimization using prefix sums or binary search.  
âœ… Use sliding window for subarrays.  
âœ… If "choose or not choose" appears, think recursion or backtracking.  
âœ… Think of dynamic programming when subproblems overlap.  
âœ… Sort intervals for interval-based problems.  
âœ… Hashing helps detect duplicates or store states quickly.  

----------------------------------------------------
ğŸ“ 6. INTERVIEW MUST-HAVE:
----------------------------------------------------
âœ… Reverse Linked List  
âœ… Merge Two Sorted Lists  
âœ… Detect Cycle in Linked List (Floydâ€™s Algorithm)  
âœ… Find Kth largest element  
âœ… Valid Parentheses (Stack)  
âœ… Top K frequent elements (Heap / Map)  
âœ… Word Break Problem (DP)  
âœ… Longest Common Subsequence  
âœ… Longest Palindromic Substring  
âœ… Rotate Array  
âœ… Missing Number / Duplicate Number problems  

----------------------------------------------------
âœ¨ REMEMBER:  
 PRACTICE. PATIENCE. PATTERN RECOGNITION. âœ¨

----------------------------------------------------
