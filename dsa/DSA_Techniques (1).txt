====================================================
                ‚úÖ CORE DSA TECHNIQUES
         Complete Guide with Explanations & Algorithms
====================================================

1Ô∏è‚É£ Brute Force
----------------------------------------------------
- Idea: Try every possible solution and pick the best result.
- Complexity: Often O(n¬≤), O(n¬≥), or worse.
- When to use: Small input sizes or as a starting solution.
- Example: Check every pair for a sum in an array.
- Algorithm Used: Nested loops or recursion with all choices tried.

2Ô∏è‚É£ Greedy Algorithms
----------------------------------------------------
- Principle: Choose the locally optimal option at each step.
- Not all problems can be solved greedily unless proven by:
  - Greedy-choice property & Optimal substructure.
- Famous Algorithms:
  - Activity Selection Problem (Earliest finish time first)
  - Huffman Encoding Tree (Min-heap based)
  - Kruskal‚Äôs MST (Union-Find for cycle detection)
  - Fractional Knapsack (Sort by value/weight ratio)

3Ô∏è‚É£ Divide and Conquer
----------------------------------------------------
- Split the problem into smaller pieces, solve them recursively, then combine.
- Used for sorting, searching, and geometry problems.
- Common Algorithms:
  - Merge Sort (O(n log n))
  - Quick Sort (Expected O(n log n))
  - Binary Search (O(log n))
  - Closest Pair of Points (O(n log n))

4Ô∏è‚É£ Recursion
----------------------------------------------------
- Function calls itself with smaller subproblems until reaching a base case.
- Can lead to exponential complexity if not optimized.
- Algorithms Using Recursion:
  - Tower of Hanoi (O(2^n))
  - Fibonacci Sequence (Exponential without memoization)
  - Factorial (O(n))

5Ô∏è‚É£ Backtracking
----------------------------------------------------
- Recursive trial-and-error with reverting choices ("undo" step).
- Used when all solutions or one valid solution needs to be found.
- Algorithms:
  - N-Queens problem
  - Sudoku solver
  - Generating permutations & combinations (recursive calls with choice revert)

6Ô∏è‚É£ Dynamic Programming (DP)
----------------------------------------------------
- Store solutions to subproblems to avoid re-computation.
- Two Approaches:
  - Top-down (Memoization)
  - Bottom-up (Tabulation)
- Algorithms:
  - Longest Common Subsequence (O(n*m))
  - Knapsack Problem (0/1 Knapsack DP)
  - Coin Change (Minimum coins or number of ways)
  - Edit Distance (Levenshtein Distance)

7Ô∏è‚É£ Sliding Window
----------------------------------------------------
- Use a fixed-size or variable-size window to find optimal subarrays or substrings.
- Algorithms:
  - Kadane‚Äôs Algorithm (Max subarray sum in O(n))
  - Longest substring without repeating characters (HashSet + window expansion)
  - Sliding Window Maximum (Deque/Monotonic Queue based)

8Ô∏è‚É£ Two Pointers
----------------------------------------------------
- Two pointers moving inward or outward to reduce complexity.
- Algorithms:
  - Merge Two Sorted Arrays
  - Reverse a String
  - Trap Rainwater (Two pointer method)

9Ô∏è‚É£ Binary Search
----------------------------------------------------
- Works on sorted/monotonic arrays or answers.
- Algorithms:
  - Standard Binary Search
  - Lower Bound / Upper Bound search
  - Search in Rotated Sorted Array
  - Binary Search on Answer (Minimize/Maximize search ranges)

üîü Bit Manipulation
----------------------------------------------------
- Using bitwise operators for efficient operations.
- Algorithms:
  - Check if number is a power of two (n & (n-1) == 0)
  - Find single non-repeating number (XOR)
  - Count set bits (Kernighan‚Äôs Algorithm)
  - Swap numbers without temp using XOR

1Ô∏è‚É£1Ô∏è‚É£ Graph Algorithms
----------------------------------------------------
- BFS (Queue based, level-by-level traversal)
- DFS (Recursive or iterative using stack)
- Dijkstra‚Äôs Algorithm (Min-heap based for shortest paths)
- Bellman-Ford (Detect negative cycles)
- Floyd-Warshall (All pairs shortest paths)
- Kruskal‚Äôs MST (Sort edges + Union-Find)
- Prim‚Äôs MST (Min-heap based)
- Topological Sort (Kahn‚Äôs Algorithm or DFS-based)
- Union-Find (Disjoint Set Union for connectivity and cycle detection)

1Ô∏è‚É£2Ô∏è‚É£ Heap / Priority Queue
----------------------------------------------------
- Retrieve smallest/largest element efficiently (log n complexity).
- Algorithms:
  - Heap Sort
  - Kth Largest Element
  - Merge k Sorted Lists
  - Median of Data Stream

1Ô∏è‚É£3Ô∏è‚É£ Trie (Prefix Tree)
----------------------------------------------------
- Stores strings character by character in tree form.
- Used for:
  - Autocomplete
  - Spell checking
  - Longest common prefix finding
  - Search in dictionaries (O(L) complexity where L is word length)

1Ô∏è‚É£4Ô∏è‚É£ Segment Tree & Fenwick Tree (BIT)
----------------------------------------------------
- Data structures for dynamic range queries with updates.
- Segment Tree: O(log n) updates & queries
- Fenwick Tree: O(log n) updates & queries
- Applications:
  - Range sum, Range min/max queries
  - Frequency queries
  - Inversion count

1Ô∏è‚É£5Ô∏è‚É£ Prefix Sum / Difference Array
----------------------------------------------------
- Precompute prefix sums for O(1) range queries.
- Difference Array used for efficient range updates.
- Applications:
  - Range sum queries
  - Applying multiple range updates efficiently

1Ô∏è‚É£6Ô∏è‚É£ Stack / Monotonic Stack
----------------------------------------------------
- LIFO structure.
- Applications:
  - Parentheses matching
  - Largest rectangle in histogram (O(n))
  - Next Greater/Smaller Element (O(n) using stack)

1Ô∏è‚É£7Ô∏è‚É£ Queue / Deque / Monotonic Queue
----------------------------------------------------
- FIFO (Queue), Double-ended structure (Deque)
- Applications:
  - BFS traversal
  - Sliding window maximum/minimum
  - 0-1 BFS (Used for shortest path when edge weights are 0 or 1)

1Ô∏è‚É£8Ô∏è‚É£ Hashing
----------------------------------------------------
- Map keys to values in O(1) expected time.
- Applications:
  - Frequency count
  - Anagram detection
  - Caching results (Memoization in DP)
  - Hash-based lookup tables

1Ô∏è‚É£9Ô∏è‚É£ Disjoint Set (Union-Find)
----------------------------------------------------
- Data structure to manage disjoint sets.
- Algorithms:
  - Union by rank & Path compression (Optimizations)
  - Used in cycle detection, Kruskal‚Äôs MST, connectivity queries

2Ô∏è‚É£0Ô∏è‚É£ Mathematical Techniques
----------------------------------------------------
- GCD (Euclid‚Äôs Algorithm)
- LCM (lcm(a,b) = (a*b) / gcd(a,b))
- Prime Sieves (Sieve of Eratosthenes for O(n log log n))
- Modular Arithmetic:
  - Fast Exponentiation (Binary exponentiation)
  - Modular inverse (Fermat‚Äôs little theorem)
  - nCr modulo (Precompute factorial & inverse)
- Combinatorics:
  - Permutations & Combinations
  - Counting paths & subsets

====================================================
üöÄ Save and master this ‚Äî every major DSA concept in one place! 
====================================================

‚ö° SUMMARY TABLE ‚ö°

| Technique                 | Common Use                                         |
|---------------------------|----------------------------------------------------|
| Brute Force               | Small inputs, first attempt                        |
| Greedy                    | Local optimal -> global optimal problems           |
| Divide & Conquer          | Sorts, Searches, Closest point problems            |
| Recursion / Backtracking  | Generate all possibilities (Perms, Combos, Sudoku) |
| Dynamic Programming       | Overlapping subproblems (Knapsack, LCS)            |
| Sliding Window            | Subarray/substring problems                        |
| Two Pointers              | Sorted arrays, paired problems                     |
| Binary Search             | Search & optimization in monotonic conditions      |
| Bit Manipulation          | Optimization, toggle/check bits, parity checks     |
| Graph Algorithms          | Traversal, paths, connectivity                     |
| Heap / Priority Queue     | Scheduling, median, top k elements                 |
| Trie                      | Prefix-based string problems                       |
| Segment/Fenwick Tree      | Dynamic range queries                              |
| Monotonic Stack / Queue   | Next greater/smaller element, histogram problems   |
| Hashing                   | Lookup, frequency analysis                         |
| Union-Find (Disjoint Set) | Connectivity, cycle detection                      |
| Mathematical Techniques   | GCD, LCM, primes, combinatorics                    |

====================================================
üëâ Master these and you'll crush DSA interviews! üí™
====================================================







====================================================
                  DATA STRUCTURES & ALGORITHMS
                      MASTER CHEAT SHEET
====================================================

üìÅ 1. CORE DATA STRUCTURES:
-----------------------------------------
‚úÖ Arrays  
‚úÖ Strings  
‚úÖ Linked Lists (Singly / Doubly)  
‚úÖ Stacks (LIFO)  
‚úÖ Queues (FIFO)  
‚úÖ Priority Queues & Heaps (Min-Heap, Max-Heap)  
‚úÖ HashMaps / HashTables / HashSets  
‚úÖ Trees  
   - Binary Trees  
   - Binary Search Trees  
   - AVL Trees  
   - Segment Trees  
   - Fenwick Tree (BIT)  
‚úÖ Tries  
‚úÖ Graphs (Adjacency List, Adjacency Matrix)  
‚úÖ Disjoint Set Union (DSU / Union-Find)  

----------------------------------------------------
üìÅ 2. ALGORITHM TECHNIQUES:
----------------------------------------------------
‚úÖ Two Pointers  
‚úÖ Sliding Window  
‚úÖ Binary Search  
‚úÖ Recursion  
‚úÖ Backtracking  
‚úÖ Divide & Conquer  
‚úÖ Dynamic Programming (DP)  
   - Memoization (Top Down)  
   - Tabulation (Bottom Up)  
‚úÖ Bit Manipulation  
‚úÖ Greedy Algorithms  
‚úÖ Graph Algorithms  
   - BFS (Breadth-First Search)  
   - DFS (Depth-First Search)  
   - Dijkstra‚Äôs Algorithm  
   - Bellman-Ford Algorithm  
   - Floyd-Warshall Algorithm  
   - Topological Sort  
   - Union-Find / DSU  
‚úÖ Fast Exponentiation  
‚úÖ Kadane‚Äôs Algorithm  
‚úÖ KMP Algorithm (String Matching)  
‚úÖ Rabin-Karp (String Search)  
‚úÖ Z-Algorithm (Pattern Matching)  
‚úÖ Prefix Sum / Suffix Sum  

----------------------------------------------------
üìÅ 3. COMMON PROBLEM PATTERNS:
----------------------------------------------------
‚úÖ Subarray problems  
‚úÖ Combinational subsets  
‚úÖ Permutations  
‚úÖ Matrix traversal  
‚úÖ Interval problems (merge intervals, meeting rooms)  
‚úÖ Stock Buy-Sell problems  
‚úÖ Knapsack problems  
‚úÖ Coin change problems  

----------------------------------------------------
üìÅ 4. COMPLEXITY CHEAT SHEET:
----------------------------------------------------
‚úÖ Array search: O(n)  
‚úÖ Binary search: O(log n)  
‚úÖ Sorting: O(n log n)  
‚úÖ BFS/DFS: O(V + E)  
‚úÖ Building a heap: O(n)  
‚úÖ Trie Insert/Search: O(L) (L = length of word)  
‚úÖ DP: Often O(n^2) or O(n*m)  
‚úÖ Matrix Traversal: O(n*m)  

----------------------------------------------------
üìÅ 5. TIPS:
----------------------------------------------------
‚úÖ Always start with brute force.  
‚úÖ Look for optimization using prefix sums or binary search.  
‚úÖ Use sliding window for subarrays.  
‚úÖ If "choose or not choose" appears, think recursion or backtracking.  
‚úÖ Think of dynamic programming when subproblems overlap.  
‚úÖ Sort intervals for interval-based problems.  
‚úÖ Hashing helps detect duplicates or store states quickly.  

----------------------------------------------------
üìÅ 6. INTERVIEW MUST-HAVE:
----------------------------------------------------
‚úÖ Reverse Linked List  
‚úÖ Merge Two Sorted Lists  
‚úÖ Detect Cycle in Linked List (Floyd‚Äôs Algorithm)  
‚úÖ Find Kth largest element  
‚úÖ Valid Parentheses (Stack)  
‚úÖ Top K frequent elements (Heap / Map)  
‚úÖ Word Break Problem (DP)  
‚úÖ Longest Common Subsequence  
‚úÖ Longest Palindromic Substring  
‚úÖ Rotate Array  
‚úÖ Missing Number / Duplicate Number problems  

----------------------------------------------------
‚ú® REMEMBER:  
 PRACTICE. PATIENCE. PATTERN RECOGNITION. ‚ú®

----------------------------------------------------
